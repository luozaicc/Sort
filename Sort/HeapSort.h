#pragma once
#include "ISort.h"

/**
 * 堆排序算法
 * 不稳定
 * 将堆看作一颗完全二叉树的顺序存储序列
 * 小顶堆对应的完全二叉树中任意结点均比其孩子小或相等；大顶堆对应的完全二叉树中任意结点均比其孩子大或相等.
		不满足这两个性质的完全二叉树其顺序存储序列不是堆
 * 思路：将大顶堆的根节点与当前最后一个元素交换，之后将前面的元素序列重新调整为大顶堆，
		然后将新的大顶堆的根节点与当前最后一个元素（即整个序列倒数第二个）交换，重复此操作。
 * 调整大顶堆：比较堆顶与其两个孩子,若堆顶不是最大则将两孩子中的大者与堆顶“交换”,
		交换后的子树可能不再是堆，重复上述操作至最后.
 * 建立初始大顶堆：从最后一个非叶子结点开始向根结点方向逐步调整建堆。
 * 最坏时间复杂度O(nlogn),比快排好,且仅用一个记录辅助空间rc,但不稳定,
	建堆在正序时最慢,适合n大杂乱
 * 
 */
class HeapSort :
	public ISort
{
public:
	HeapSort();
	~HeapSort();
	virtual void Sort(ISortObj* objs[], int len);
	void HeapAdjust(ISortObj* o[], int len, int root);
};

